package systemd

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

const (
	servicePath      = "/etc/systemd/system/dnsbro.service"
	binaryPath       = "/usr/local/bin/dnsbro"
	resolvPath       = "/etc/resolv.conf"
	resolvBackupPath = "/etc/resolv.conf.dnsbro.bak"
)

// Install writes the service file, updates resolver settings, and enables dnsbro via systemctl.
func Install(configPath string, listen string) error {
	exe, err := os.Executable()
	if err != nil {
		return fmt.Errorf("find executable: %w", err)
	}

	if err := copyFile(exe, binaryPath); err != nil {
		return fmt.Errorf("copy binary: %w", err)
	}

	unit := serviceUnit(configPath)
	if err := os.WriteFile(servicePath, []byte(unit), 0o644); err != nil {
		return fmt.Errorf("write service: %w", err)
	}

	if err := runSystemctl("daemon-reload"); err != nil {
		return err
	}
	if err := runSystemctl("enable", "dnsbro"); err != nil {
		return err
	}
	if err := runSystemctl("start", "dnsbro"); err != nil {
		return err
	}
	if err := runSystemctl("is-active", "--quiet", "dnsbro"); err != nil {
		_ = runSystemctl("disable", "dnsbro")
		return fmt.Errorf("dnsbro service did not start cleanly: %w", err)
	}

	if err := ensureResolver(listen); err != nil {
		_ = runSystemctl("stop", "dnsbro")
		_ = runSystemctl("disable", "dnsbro")
		return fmt.Errorf("configure resolver: %w", err)
	}

	return nil
}

// Uninstall removes the service and binary and restores DNS if we have a backup.
func Uninstall() error {
	_ = exec.Command("systemctl", "stop", "dnsbro").Run()
	_ = exec.Command("systemctl", "disable", "dnsbro").Run()
	_ = restoreResolver()
	_ = os.Remove(servicePath)
	return os.Remove(binaryPath)
}

// Revert stops the service and restores DNS if we have a backup.
func Revert() error {
	_ = exec.Command("systemctl", "stop", "dnsbro").Run()
	return restoreResolver()
}

func ServicePath() string { return servicePath }
func BinaryPath() string  { return binaryPath }

func serviceUnit(configPath string) string {
	return fmt.Sprintf(`[Unit]
Description=dnsbro local DNS resolver
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=%s serve --config %s
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
User=root
AmbientCapabilities=CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
`, binaryPath, configPath)
}

func runSystemctl(args ...string) error {
	cmd := exec.Command("systemctl", args...)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("systemctl %s: %v: %s", strings.Join(args, " "), err, bytes.TrimSpace(out))
	}
	return nil
}

func copyFile(src, dst string) error {
	if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil {
		return err
	}
	in, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	return os.WriteFile(dst, in, 0o755)
}

func ensureResolver(listen string) error {
	host := stripPort(listen)
	if host == "" {
		return errors.New("listen host missing")
	}

	current, _ := os.ReadFile(resolvPath)
	if resolvContainsHost(current, host) {
		return nil
	}

	if err := backupResolv(current); err != nil {
		return fmt.Errorf("backup %s: %w", resolvPath, err)
	}

	if info, err := os.Lstat(resolvPath); err == nil && info.Mode()&os.ModeSymlink != 0 {
		if err := os.Remove(resolvPath); err != nil {
			return fmt.Errorf("remove symlink %s: %w", resolvPath, err)
		}
	}

	content := fmt.Sprintf("# Generated by dnsbro on %s; original saved to %s\nnameserver %s\n", time.Now().Format(time.RFC3339), resolvBackupPath, host)
	if err := os.WriteFile(resolvPath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write %s: %w", resolvPath, err)
	}
	return nil
}

func backupResolv(data []byte) error {
	if _, err := os.Stat(resolvBackupPath); err == nil {
		return nil
	}
	return os.WriteFile(resolvBackupPath, data, 0o644)
}

func restoreResolver() error {
	data, err := os.ReadFile(resolvBackupPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil
		}
		return err
	}
	if err := os.WriteFile(resolvPath, data, 0o644); err != nil {
		return err
	}
	return os.Remove(resolvBackupPath)
}

func resolvContainsHost(b []byte, host string) bool {
	sc := bufio.NewScanner(bytes.NewReader(b))
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, ";") {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) >= 2 && strings.EqualFold(fields[0], "nameserver") {
			if stripPort(fields[1]) == host {
				return true
			}
		}
	}
	return false
}

func stripPort(addr string) string {
	host, _, err := net.SplitHostPort(addr)
	if err == nil {
		return host
	}
	return addr
}
